\documentclass[rail]{beamer}
\usecolortheme[RGB={153,0,0}]{structure}
\usetheme{Rochester}
%\useinnertheme{rounded}
\setbeamertemplate{blocks}[rounded][shadow=true]
\useinnertheme{rectangles}
\usepackage[utf8]{inputenc}
\usepackage{idrislang}
\usepackage{listings}
\usepackage{natbib}
\usepackage{bibentry}
\usepackage{color}
\usepackage[spanish]{babel}
\usepackage{amssymb,latexsym}
\usepackage{xcolor}
\usepackage{alltt}

\setbeamertemplate{navigation symbols}{}
%\bibliography{Erlang}

\lstdefinestyle{idris-style}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  %%frame=L,
  xleftmargin=\parindent,
  language=idris,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily\color{blue},
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{black},
  stringstyle    =\color{red},
}

\lstset{style=idris-style}%

\title{\idris}
\subtitle{A language with dependent types}
\author{Alejandro Gómez Londoño}
\date{17th March, 2014}
\institute{EAFIT University}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{What is \idris}
  \begin{quotation}
    “What if Haskell had full dependent types?”
    \footnote[frame,1]{ Edwin Brady (2013). Idris, a general-purpose
      dependently typed programming language: Design and
      implementation. Journal of Functional Programming, 23, pp
      552-593.}
  \end{quotation}
\end{frame}

\begin{frame}{\idris features}
  \begin{itemize}
    \item Full dependent types
    \item Type classes
    \item \texttt{where} clauses, \texttt{do} notation,\texttt{let} bindings
    \item Monad comprehensions
    \item Totality checking
    \item Cumulative universes
    \item Tactic based theorem proving
    \item Simple foreign function interface (to C)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{\idris}{Basic Types}
\begin{alltt}

  {\color{red}{Z}} : {\color{blue}{Nat}}
  {\color{red}{50}} : {\color{blue}{Integer}}
  {\color{red}{1.23}} : {\color{blue}{Float}}
  {\color{red}{True}} : {\color{blue}{Bool}}
  {\color{red}{'a'}} : {\color{blue}{Char}}
  {\color{red}{"foo"}} : {\color{blue}{String}}

  {\color{red}{[1,2,3]}} : {\color{blue}{List Integer}}
  {\color{red}{[1,2,3]}} : {\color{blue}{Vect 3 Integer}}
\end{alltt}
\end{frame}

\begin{frame}[fragile]{\idris}
  {Data Types\footnote[frame,1]
    {Programming in Idris: a tutorial, Edwin Brady January 2012}}
  \begin{lstlisting}
    data Nat = Z | S Nat

    data Bool = True | False

    infixr 10 ::
    data List a = Nill | (::) a (List a)

    record Person : Type where
      MkPerson : (name : String) ->
                 (age : Int) -> Person
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\idris}
  {functions\footnote[frame,1]
    {Programming in Idris: a tutorial, Edwin Brady January 2012}}
  \begin{lstlisting}
    plus : Nat -> Nat -> Nat
    plus Z y     = y
    plus (S k) y = S (plus k y)

    mult : Nat -> Nat -> Nat
    mult Z y     = Z
    mult (S k) y = plus y (mult k y)

    fact : Nat -> Nat
    fact Z = 1
    fact (S k) = (S k)*(fact k)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{\idris}
  {\texttt{do,where,let}\footnote[frame,1]
    {Programming in Idris: a tutorial, Edwin Brady January 2012}}
\begin{lstlisting}
  mirror : List a -> List a
  mirror xs = let xs' = reverse xs in
                  xs ++ xs'

  even : Nat -> Bool
  even Z = True
  even (S k) = odd k where
    odd Z = False
    odd (S k) = even k

  greet : IO ()
  greet = do putStr "What is your name? "
    name <- getLine
    putStrLn ("Hello " ++ name)


\end{lstlisting}
\end{frame}

\begin{frame}{Dependent Types}{Definition}
  \begin{quotation}
    In conventional programming languages, there is a clear
    distinction between types and values... \\
    In a language with dependent types, however, the distinction is
    less clear. Dependent types allow types to ``depend'' on values -
    in other words, types are a first class language construct and can
    be manipulated like any other value.\footnote[frame,1]
    {Programming in Idris: a tutorial, Edwin Brady January 2012}
  \end{quotation}
\end{frame}

\begin{frame}{Dependent Types}{An Example}
  data Vect : Nat -> Type -> Type where
    Nil : Vect Z a
    (::) : a -> Vect k a -> Vect (S k) a

    data VectSum : Nat -> Nat -> Type where
      Nil : VectSum Z Z
      (::) : (b : Nat) -> VectSum k a -> VectSum (S k) (a + b)

\end{frame}


\end{document}
